service:
  name: agenticloop
  log_level: info

database:
  path: ./data/agenticloop.db

api:
  listen: "127.0.0.1:8090"
  token: "${AGENTICLOOP_API_TOKEN}"
  stream_poll_interval: 700ms
  stream_heartbeat_interval: 15s

ductile:
  base_url: "http://127.0.0.1:8080"
  token: "${DUCTILE_TOOL_TOKEN}"
  allowlist:
    - "echo/poll"
    - "jina-reader/handle"

llm:
  provider: openai
  model: gpt-5-nano
  api_key: "${OPENAI_API_KEY}"
  max_tokens: 4096

agent:
  default_max_loops: 10
  default_deadline: 5m
  step_timeout: 120s
  max_retry_per_step: 3
  queue_capacity: 100
  enqueue_timeout: 2s
  workspace_dir: "./data/workspaces"
  prompts:
    frame: |
      <stage name="frame">
      <role>You are in the FRAME stage for an autonomous run.  Think about what needs to be done.</role>
      <run_context version="1">
      <goal source="run.goal">{{.Goal}}</goal>
      <static_context source="run.context">{{.Context}}</static_context>
      <constraints source="run.constraints">{{.Constraints}}</constraints>
      <loop_state iteration="{{.Iteration}}" max_loops="{{.MaxLoops}}"></loop_state>
      <next_focus source="stage.reflect">{{.NextFocus}}</next_focus>
      <run_memory source="workspace.run_memory">{{.Memory}}</run_memory>
      <state source="workspace.state">{{.State}}</state>
      </run_context>
      <output_contract format="json">
      Return JSON only:
      {
        "todo": [{"id":"T1","task":"string","done":false}],
        "evidence": ["path-or-fact", "..."],
        "notes": ["string", "..."]
      }
      </output_contract>
      </stage>
    plan: |
      <stage name="plan">
      <role>You are in the PLAN stage for an autonomous run. Consider your available tools and make a todo list.</role>
      <run_context version="1">
      <goal source="run.goal">{{.Goal}}</goal>
      <static_context source="run.context">{{.Context}}</static_context>
      <constraints source="run.constraints">{{.Constraints}}</constraints>
      <loop_state iteration="{{.Iteration}}" max_loops="{{.MaxLoops}}"></loop_state>
      <next_focus source="stage.reflect">{{.NextFocus}}</next_focus>
      <run_memory source="workspace.run_memory">{{.Memory}}</run_memory>
      <state source="workspace.state">{{.State}}</state>
      </run_context>
      <frame_output source="stage.frame">{{.Frame}}</frame_output>
      <output_contract format="markdown">
      Return a short numbered plan for this loop. Prefer one concrete next action.
      </output_contract>
      </stage>
    act: |
      <stage name="act">
      <role>You are in the ACT stage for an autonomous run. Use your tool, to complete the plan</role>
      <run_context version="1">
      <goal source="run.goal">{{.Goal}}</goal>
      <static_context source="run.context">{{.Context}}</static_context>
      <constraints source="run.constraints">{{.Constraints}}</constraints>
      <loop_state iteration="{{.Iteration}}" max_loops="{{.MaxLoops}}"></loop_state>
      <run_memory source="workspace.run_memory">{{.Memory}}</run_memory>
      <state source="workspace.state">{{.State}}</state>
      </run_context>
      <frame_output source="stage.frame">{{.Frame}}</frame_output>
      <plan_output source="stage.plan">{{.Plan}}</plan_output>
      <available_tools source="runtime.bound_tools">
      {{.AvailableTools}}
      <note>Workspace tools are sandboxed to the run workspace. Use relative paths only.</note>
      <note>workspace_edit defaults to preview (apply=false); applying requires expected_original_sha256 from preview output.</note>
      <note>Completion requires calling report_success with summary and evidence.</note>
      </available_tools>
      <output_contract format="markdown">
      Execute the best next action. Use tools when needed.
      When complete for this loop, provide a concise action result.
      </output_contract>
      </stage>
    reflect: |
      <stage name="reflect">
      <role>You are in the REFLECT stage for an autonomous run. Assess the eficacy of the last action, and update the todo list.</role>
      <run_context version="1">
      <goal source="run.goal">{{.Goal}}</goal>
      <loop_state iteration="{{.Iteration}}" max_loops="{{.MaxLoops}}"></loop_state>
      <run_memory source="workspace.run_memory">{{.Memory}}</run_memory>
      <loop_memory source="workspace.loop_memory">{{.LoopMemory}}</loop_memory>
      <state source="workspace.state">{{.State}}</state>
      </run_context>
      <frame_output source="stage.frame">{{.Frame}}</frame_output>
      <plan_output source="stage.plan">{{.Plan}}</plan_output>
      <act_output source="stage.act">{{.Act}}</act_output>
      <completion_gate success_tool="report_success" success_tool_called="{{.SuccessReported}}">
      <reported_summary>{{.SuccessSummary}}</reported_summary>
      </completion_gate>
      <output_contract format="json">
      Return JSON only:
      {
        "next_stage": "plan|act|done",
        "done": boolean,
        "summary": "string",
        "next_focus": "string",
        "memory_update": "string",
        "updated_state": {
          "todo": [{"id":"T1","task":"string","done":true}],
          "evidence": ["path-or-fact", "..."],
          "notes": ["string", "..."]
        }
      }
      </output_contract>
      </stage>
