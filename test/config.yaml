service:
  name: agenticloop
  log_level: info

database:
  path: ./data/agenticloop.db

api:
  listen: "127.0.0.1:8090"
  token: "${AGENTICLOOP_API_TOKEN}"

ductile:
  base_url: "http://127.0.0.1:8080"
  token: "${DUCTILE_TOOL_TOKEN}"
  allowlist:
    - "echo/poll"
    - "echo/handle"
    - "fabric/handle"
    - "file_handler/handle"
    - "youtube_transcript/handle"

llm:
  provider: openai
  model: gpt-4o-mini
  api_key: "${OPENAI_API_KEY}"

agent:
  default_max_loops: 10
  default_deadline: 5m
  step_timeout: 120s
  max_retry_per_step: 3
  max_act_rounds: 6
  workspace_dir: "./data/workspaces"
  save_loop_memory: true
  prompts:
    frame: |
      <stage name="frame">
      <role>You are in the FRAME stage for an autonomous run.  Think about what needs to be done.</role>
      <run_context version="1">
      <goal source="run.goal">{{.Goal}}</goal>
      <static_context source="run.context">{{.Context}}</static_context>
      <constraints source="run.constraints">{{.Constraints}}</constraints>
      <loop_state iteration="{{.Iteration}}" max_loops="{{.MaxLoops}}"></loop_state>
      <next_focus source="stage.reflect">{{.NextFocus}}</next_focus>
      <run_memory source="workspace.run_memory">{{.Memory}}</run_memory>
      </run_context>
      <output_contract format="markdown">
      Return concise markdown with:
      - objective
      - known facts
      - unknowns to resolve
      - success condition
      </output_contract>
      </stage>
    plan: |
      <stage name="plan">
      <role>You are in the PLAN stage for an autonomous run. Consider your available tools and make a todo list.</role>
      <run_context version="1">
      <goal source="run.goal">{{.Goal}}</goal>
      <static_context source="run.context">{{.Context}}</static_context>
      <constraints source="run.constraints">{{.Constraints}}</constraints>
      <loop_state iteration="{{.Iteration}}" max_loops="{{.MaxLoops}}"></loop_state>
      <next_focus source="stage.reflect">{{.NextFocus}}</next_focus>
      <run_memory source="workspace.run_memory">{{.Memory}}</run_memory>
      </run_context>
      <frame_output source="stage.frame">{{.Frame}}</frame_output>
      <output_contract format="markdown">
      Return a short numbered plan for this loop. Prefer one concrete next action.
      </output_contract>
      </stage>
    act: |
      <stage name="act">
      <role>You are in the ACT stage for an autonomous run. Use your tools to complete the plan.</role>
      <run_context version="1">
      <goal source="run.goal">{{.Goal}}</goal>
      <static_context source="run.context">{{.Context}}</static_context>
      <constraints source="run.constraints">{{.Constraints}}</constraints>
      <loop_state iteration="{{.Iteration}}" max_loops="{{.MaxLoops}}"></loop_state>
      <run_memory source="workspace.run_memory">{{.Memory}}</run_memory>
      </run_context>
      <frame_output source="stage.frame">{{.Frame}}</frame_output>
      <plan_output source="stage.plan">{{.Plan}}</plan_output>
      <available_tools source="runtime.bound_tools">
      <tool>sys_internal_ip</tool>
      <tool>sys_external_ip</tool>
      <tool>workspace_write — create/overwrite a file (path, content)</tool>
      <tool>workspace_read — read a file (path, max_lines)</tool>
      <tool>workspace_list — list directory entries (path)</tool>
      <tool>workspace_append — append to a file (path, content)</tool>
      <tool>workspace_delete — delete a file (path)</tool>
      <tool>workspace_mkdir — create directory and parents (path)</tool>
      <tool>report_success</tool>
      <note>Additional tools may be available at runtime (for example ductile_*).</note>
      <note>Workspace tools are sandboxed to the run workspace. Use relative paths only.</note>
      <note>Completion requires calling report_success with summary and evidence.</note>
      </available_tools>
      <output_contract format="markdown">
      Execute the best next action. Use tools when needed.
      When complete for this loop, provide a concise action result.
      </output_contract>
      </stage>
    reflect: |
      <stage name="reflect">
      <role>You are in the REFLECT stage for an autonomous run. Assess the efficacy of the last action, and update the todo list.</role>
      <run_context version="1">
      <goal source="run.goal">{{.Goal}}</goal>
      <loop_state iteration="{{.Iteration}}" max_loops="{{.MaxLoops}}"></loop_state>
      <run_memory source="workspace.run_memory">{{.Memory}}</run_memory>
      <loop_memory source="workspace.loop_memory">{{.LoopMemory}}</loop_memory>
      </run_context>
      <frame_output source="stage.frame">{{.Frame}}</frame_output>
      <plan_output source="stage.plan">{{.Plan}}</plan_output>
      <act_output source="stage.act">{{.Act}}</act_output>
      <completion_gate success_tool="report_success" success_tool_called="{{.SuccessReported}}">
      <reported_summary>{{.SuccessSummary}}</reported_summary>
      </completion_gate>
      <output_contract format="json">
      Return JSON only:
      {"done": boolean, "summary": "string", "next_focus": "string", "memory_update": "string"}
      </output_contract>
      </stage>
